Programming Project 3 - Minix User Space Memory Manager
Name: Xiaoyuan Lu, Yongfeng Zhang
CATS: xl37136, yozhang
CMPS111, Winter 2014

====== Purpose (referenced from the specification pdf) ======

The main purpose of this project is to write two user-space memory allocators, namely buddy allocator and free list allocator, that are
supposed to manage memory resource (allocate and free) for processes in MINIX. We don't need to modify the kernel, We are supposed to write the two allocators from scratch, and build a library out of the source files. Hopefully, this project will further familiarize us with
direct memory manipulation in C and how the memory management algorithms work.

====== Available Resources ======

We referenced the Free-Space Management chapter of the book provided in the slides. It gives a very detailed description of free list algorithms and buddy allocation. Our high-level design of free list is very similar to the one described in this book. We also referenced
the last section of the classical K&R's The C Programming Language book. It has a good discussion on padding and alignment issues, as well
as a simple free list implementation.

====== Design ======

The Interfaces and Data structures:

We are to implement the meminit(), memalloc() and memfree() functions in libmem.c, the free list allocators and the buddy allocator in 
freelist_allocatros.c and bu_allocator.c, respectively. And we have all of out data structures defined and functions declared in libmem.h.

In order to use a single integer handle to denote each memory initialization (meminit), we defined an array of structures, with each element
in that array storing all the information about the initialization of a particular allocator. This array is defined as a global data structure
and is defined statically, thus memalloc() can just use an index number (int handle) to access the information and memory address initialized
in the corresponding meminit(). So in libmem.h we have:

struct handle{
    unsigned int flags;
    char *memstart;      /* the address of the memory pool */
    long int n_bytes;	/* the size of the memory pool */
    int numNodes;      /* track the number of nodes that have unallocated memory */

    struct fl_node *freelist;  /* the start address of this handle's free list */
    struct fl_node *visited;    /* store the previously visited node ,used for next fit */
    struct bu_node *bm_head;   /* the start address of this handle's bitmap */
    int bu_depth;          
    int page_size;
} handlers[MAX_HANDLE];

This struct stores all the information we need to implement the buddy allocator and free list allocators. And another global variable
handleCount is used to denote the number of initializations, it starts with 0 and increases by 1 in each meminit() call. memalloc() uses the
handleCount returned by meminit() to get the information, and pass it to the intended allocators defined in freelist_allocators.c and
bu_allocator.c.

The design of the Free list allocator:

We implemented the linked list right in the same memory pool allocated by the OS in meminit() by adding an overhead to each memory block,
because due to the requirements, we cannot ask the OS for any more memory after the initialization of the allocator, so storing the nodes of
the linked list in another memory space would be wrong. The implementation (in meminit) is as follows:

We first ask the OS for a large memory pool: handlers[handleCount].memstart = malloc(n_bytes);

Then we let the start address of our free list point to the start of the memory pool: 
handlers[handleCount].freelist = handlers[handleCount].memstart;

Thus we can use this pointer to directly write the memory pool to add header to each memory block.

We defined our free list header as:

struct fl_node{
    int size;             /* size of this memory block */
    int used;             /* if it's used or it's free */
    char *blockstart;       /* the address of the actual memory block (excluding the header) */
    struct fl_node* next;
};

The way we build the free list is as follows:

------------<-------node1                    
|   size   |
------------                                
|   used   |			    At initialization, we add one header at the top of the allocated memory pool to track the whole memory.
------------                        Note that the actual allocatable memory begins at *blockstart, and the size is the size of the actual
|blockstart|------|	    	    memory, excluding the header size. By pointing the free list to node1 position, we can write our header
------------      |                 info. like this. The left figure is the memory layout at initialization.
|   next   |      |                      
------------<-----|
|          |                   
|          |                              
|          |                        ||
|   mem    |			    ||
|	   |			    || memalloc()
|	   |			    ||  called
------------			    ||	
				    ||	
				    \/
------------<------node1
|   size   |
------------
|   used   |			    
------------
|blockstart|------|
------------      |
|   next   |      |		    When memalloc() is called, we allocate a piece of memory to the user (by returning blockstart),
------------<-----|
|          |
|   mem    | 
|          |
------------<------node2
|   size   |
------------
|   used   |
------------
|blockstart|------|
------------      |
|   next   |      |
------------<-----|
|          |
|   mem    | 
|          |
------------




