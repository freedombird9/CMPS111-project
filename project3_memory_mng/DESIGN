Programming Project 3 - Minix User Space Memory Manager
Name: Xiaoyuan Lu, Yongfeng Zhang
CATS: xl37136, yozhang
CMPS111, Winter 2014

====== Purpose (referenced from the specification pdf) ======

The main purpose of this project is to write two user-space memory allocators, namely buddy allocator and free list allocator, that are
supposed to manage memory resource (allocate and free) for processes in MINIX. We don't need to modify the kernel, We are supposed to write the two allocators from scratch, and build a library out of the source files. Hopefully, this project will further familiarize us with
direct memory manipulation in C and how the memory management algorithms work.

====== Available Resources ======

We referenced the Free-Space Management chapter of the book provided in the slides. It gives a very detailed description of free list algorithms and buddy allocation. Our high-level design of free list is very similar to the one described in this book. We also referenced
the last section of the classical K&R's The C Programming Language book. It has a good discussion on padding and alignment issues, as well
as a simple free list implementation.

====== Design ======

The Interfaces and Data structures:

We are to implement the meminit(), memalloc() and memfree() functions in libmem.c, the free list allocators and the buddy allocator in 
freelist_allocatros.c and bu_allocator.c, respectively. And we have all of out data structures defined and functions declared in libmem.h.

In order to use a single integer handle to denote each memory initialization (meminit), we defined an array of structures, with each element
in that array storing all the information about the initialization of a particular allocator. This array is defined as a global data structure
and is defined statically, thus memalloc() can just use an index number (int handle) to access the information and memory address initialized
in the corresponding meminit(). So in libmem.h we have:

struct handle{
    unsigned int flags;
    char *memstart;      /* the address of the memory pool */
    long int n_bytes;	/* the size of the memory pool */
    int numNodes;      /* track the number of nodes that have unallocated memory */

    struct fl_node *freelist;  /* the start address of this handle's free list */
    struct fl_node *visited;    /* store the previously visited node ,used for next fit */
    struct bu_node *bm_head;   /* the start address of this handle's bitmap */
    int bu_depth;          
    int page_size;
} handlers[MAX_HANDLE];

This struct stores all the information we need to implement the buddy allocator and free list allocators. And another global variable
handleCount is used to denote the number of initializations, it starts with 0 and increases by 1 in each meminit() call. memalloc() uses the
handleCount returned by meminit() to get the information, and pass it to the intended allocators defined in freelist_allocators.c and
bu_allocator.c.

Design of the Free List Allocator:

We implemented the linked list right in the same memory pool allocated by the OS in meminit() by adding an overhead to each memory block,
because due to the requirements, we cannot ask the OS for any more memory after the initialization of the allocator, so storing the nodes of
the linked list in another memory space would be wrong. The implementation (in meminit) is as follows:

We first ask the OS for a large memory pool: handlers[handleCount].memstart = malloc(n_bytes);

Then we let the start address of our free list point to the start of the memory pool: 
handlers[handleCount].freelist = handlers[handleCount].memstart;

Thus we can use this pointer to directly write the memory pool to add header to each memory block.

We defined our free list header as:

struct fl_node{
    int size;             /* size of this memory block */
    int used;             /* if it's used or it's free */
    char *blockstart;       /* the address of the actual memory block (excluding the header) */
    struct fl_node* next;
};

The way we build the free list is as follows:

------------<-------node1                    
|   size   |
------------                                
|   used   |			    At initialization, we add one header at the top of the allocated memory pool to track the whole memory.
------------                        Note that the actual allocatable memory begins at *blockstart, and the size is the size of the actual
|blockstart|------|	    	    memory, excluding the header size. By pointing the free list to node1 position, we can write our header
------------      |                 info. like this. The left figure is the memory layout at initialization.
|   next   |      |                      
------------<-----|
|          |                   
|          |                              
|          |                        ||
|   mem    |			    ||
|	   |			    || memalloc()
|	   |			    ||  called
------------			    ||	
				    ||	
				    \/
------------<------node1
|   size   |
------------
|   used   |			    
------------
|blockstart|------|
------------      |
|   next   |      |		    When memalloc() is called, we allocate a piece of memory to the user (by returning blockstart), and move 
------------<-----|		    the pointer down n_bytes (the size allocated) to be the address of node2. We then can use this pointer to
|          |		  	    write the header of node2 and calculate node2's blockstart value. Finally, we link node1 and node2 using
|   mem    | 			    the next pointer of node1.
|          |			    
------------<------node2	    When memalloc() is further called, we can just repeat this mechanism to build up our free list.
|   size   |			   
------------			    Here is a design subtlty, if the memory left after a certain memalloc() call is not large enough to store
|   used   |			    the header of the new node, we just allocate all the memory of the chosen node and mark it as used. 
------------
|blockstart|------|
------------      |
|   next   |      |
------------<-----|
|          |
|   mem    | 
|          |
------------

So as we can see, the header and the memory under its management is glued together in the same memory space. After some frees, the holes are also in the same linked list in this address space. Some implementations use one list for the free nodes, and another for the used nodes,
which might be logically cleaner and may simplify the searching for free nodes and used nodes. But since we cannot ask the OS for any more heap after the initilization and we want to dynamically create and delete nodes instead of sparing another piece of memroy and keep a certain
number of nodes there during initialization, we need to maintain two lists on the same address space if we want to do so, which is complex and unnecessary.

The implementation of first fit, next fit, best fit, worst fit and random fit is pretty straightforward. You can refer to the source code, which is well commented, for details.

Memory Free:

When we want to free a block of memory, we call memfree(void *p), thus the only information we have is the address. So first we have to search
through all the handlers to check if the address is in that handler. Once we found the handler, we can get its flags to see whether the memory
is managed by free list or by buddy allocator.

For memory frees in the free list, we first search through the nodes and compare the address to be freed with the blockstart member of each node, and once we find a match, we set this node as unused. Then we need to check if we can coalesce neighboring nodes. Keeping the holes and
allocated nodes in the same memory space makes it quite simple, we can just access its previous and next nodes (if there is any) to see if we
can coalesce them.

Design of Buddy Allocator:





========= Tests =========

First Test:

We conducted two tests, the first is the required one for the free list allocators. We designed our own workload, which is a bunch of 
memalloc() and memfree()s, and used our library function to calculate the attributes that reflect the performance of an allocator. The file
for this first test is test1.c, you can just compile it and run it to see the results printed on the screen. If you want to check whether
the free list allocators we implemented behave in the right way or not, you can go into the source code file libmem.c and comment in the line: #define _VERBOSE_. Then when you run the test, the linked list will be printed out each time memalloc() or memfree() is called. It shows you the used/unused and size info. Each node is separated by a "+" symbol on the screen.

Second Test:



